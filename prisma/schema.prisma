generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  USER
}

enum TournamentFormat {
  SINGLE_ELIMINATION
  DOUBLE_ELIMINATION
  ROUND_ROBIN
  SWISS
  CREW_BATTLE
}

enum TournamentStatus {
  DRAFT
  REGISTRATION_OPEN
  REGISTRATION_CLOSED
  CHECKIN_OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum MatchStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  DQ
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  username      String    @unique
  password      String
  role          Role      @default(USER)
  province      String
  avatar        String?
  bio           String?
  wins          Int       @default(0)
  losses        Int       @default(0)
  points        Int       @default(0)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relaciones
  mainCharacters     UserCharacter[]
  tournamentsCreated Tournament[]     @relation("TournamentCreator")
  registrations      Registration[]
  matchesAsPlayer1   Match[]          @relation("Player1")
  matchesAsPlayer2   Match[]          @relation("Player2")
  matchesWon         Match[]          @relation("MatchWinner")
  gamesWon           MatchGame[]
  rankings           Ranking[]

  @@index([username])
  @@index([province])
}

model Character {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  icon        String
  series      String
  dlc         Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relaciones
  skins          CharacterSkin[]
  userCharacters UserCharacter[]
  registrations  Registration[]

  @@index([slug])
}

model Stage {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  image       String
  legal       Boolean  @default(true)
  starter     Boolean  @default(false)  // Starter stages (available in game 1)
  counterpick Boolean  @default(false)  // Counterpick stages (available after game 1)
  order       Int      @default(0)      // Display order
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([slug])
  @@index([legal])
}

model CharacterSkin {
  id          String   @id @default(cuid())
  characterId String
  name        String
  number      Int
  image       String
  createdAt   DateTime @default(now())

  // Relaciones
  character     Character        @relation(fields: [characterId], references: [id], onDelete: Cascade)
  userCharacters UserCharacter[]
  registrations Registration[]

  @@unique([characterId, number])
  @@index([characterId])
}

model UserCharacter {
  id         String   @id @default(cuid())
  userId     String
  characterId String
  skinId     String
  isPrimary  Boolean  @default(false)
  createdAt  DateTime @default(now())

  // Relaciones
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  character Character     @relation(fields: [characterId], references: [id], onDelete: Cascade)
  skin      CharacterSkin @relation(fields: [skinId], references: [id], onDelete: Cascade)

  @@unique([userId, characterId, skinId])
  @@index([userId])
}

model Tournament {
  id                String           @id @default(cuid())
  name              String
  description       String?
  slug              String           @unique
  banner            String?
  province          String
  isOnline          Boolean          @default(false)
  format            TournamentFormat
  status            TournamentStatus @default(DRAFT)
  maxParticipants   Int?
  currentParticipants Int           @default(0)
  
  // Fechas
  startDate         DateTime
  registrationStart DateTime
  registrationEnd   DateTime
  checkinStart      DateTime
  checkinEnd        DateTime
  
  // Reglas
  rules             String?
  stageList         String?
  ruleset           Json?
  
  // Metadata
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  createdById       String

  // Relaciones
  creator       User           @relation("TournamentCreator", fields: [createdById], references: [id])
  registrations Registration[]
  brackets      Bracket[]
  matches       Match[]
  rankings      Ranking[]

  @@index([slug])
  @@index([province])
  @@index([status])
  @@index([startDate])
}

model Registration {
  id             String   @id @default(cuid())
  userId         String
  tournamentId   String
  characterId    String?
  skinId         String?
  checkedIn      Boolean  @default(false)
  checkedInAt    DateTime?
  seed           Int?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relaciones
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  character  Character? @relation(fields: [characterId], references: [id])
  skin       CharacterSkin? @relation(fields: [skinId], references: [id])

  @@unique([userId, tournamentId])
  @@index([tournamentId])
  @@index([userId])
}

model Bracket {
  id           String   @id @default(cuid())
  tournamentId String   @unique
  type         String   // "double_elimination", "single_elimination", etc.
  data         Json     // Estructura del bracket completo
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relaciones
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
}

model Match {
  id               String      @id @default(cuid())
  tournamentId     String
  bracketType      String      // "WINNERS", "LOSERS", "GRANDS"
  round            Int
  matchNumber      Int
  player1Id        String?
  player2Id        String?
  player1Score     Int         @default(0)
  player2Score     Int         @default(0)
  winnerId         String?
  status           String      @default("PENDING") // "PENDING", "CHECKIN", "BANNING", "SELECTING", "PLAYING", "REPORTING", "COMPLETED", "DQ"
  
  // Check-in
  player1CheckIn   Boolean     @default(false)
  player2CheckIn   Boolean     @default(false)
  checkInDeadline  DateTime?
  
  // Current game state
  currentGame      Int         @default(1)
  bestOf           Int         @default(3)
  
  // Match data (stores ban/pick history)
  matchData        Json?       // { games: [{ bans: [], stage: "", characters: {}, winner: "" }] }
  
  nextMatchId      String?
  loserNextMatchId String?
  startedAt        DateTime?
  completedAt      DateTime?
  notes            String?
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  // Relaciones
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  player1    User?      @relation("Player1", fields: [player1Id], references: [id])
  player2    User?      @relation("Player2", fields: [player2Id], references: [id])
  winner     User?      @relation("MatchWinner", fields: [winnerId], references: [id])
  games      MatchGame[]

  @@index([tournamentId])
  @@index([player1Id])
  @@index([player2Id])
  @@index([winnerId])
  @@index([status])
}

model MatchGame {
  id            String   @id @default(cuid())
  matchId       String
  gameNumber    Int
  
  // Stage banning/selection
  bannedStages  String[] // Array de IDs de stages baneados
  selectedStage String?  // ID del stage seleccionado
  
  // Character selection
  player1Character String?
  player2Character String?
  
  // Result
  winnerId      String?
  reportedBy    String?  // User ID who reported
  confirmedBy   String?  // User ID who confirmed
  
  status        String   @default("PENDING") // "PENDING", "BANNING", "STAGE_SELECT", "CHAR_SELECT", "PLAYING", "REPORTING", "COMPLETED"
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relaciones
  match   Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  winner  User? @relation(fields: [winnerId], references: [id])

  @@index([matchId])
  @@index([winnerId])
}

model Ranking {
  id           String   @id @default(cuid())
  userId       String
  tournamentId String
  placement    Int
  points       Int      @default(0)
  createdAt    DateTime @default(now())

  // Relaciones
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@unique([userId, tournamentId])
  @@index([userId])
  @@index([tournamentId])
  @@index([points])
}
