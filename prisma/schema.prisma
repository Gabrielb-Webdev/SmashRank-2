generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  USER
}

enum TournamentFormat {
  SINGLE_ELIMINATION
  DOUBLE_ELIMINATION
  ROUND_ROBIN
  SWISS
  CREW_BATTLE
}

enum TournamentStatus {
  DRAFT
  REGISTRATION_OPEN
  REGISTRATION_CLOSED
  CHECKIN_OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum MatchStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  DQ
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  username      String    @unique
  password      String
  role          Role      @default(USER)
  province      String
  avatar        String?
  bio           String?
  wins          Int       @default(0)
  losses        Int       @default(0)
  points        Int       @default(0)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relaciones
  mainCharacters     UserCharacter[]
  tournamentsCreated Tournament[]     @relation("TournamentCreator")
  registrations      Registration[]
  matchesAsPlayer1   Match[]          @relation("Player1")
  matchesAsPlayer2   Match[]          @relation("Player2")
  matchesWon         Match[]          @relation("MatchWinner")
  gamesWon           MatchGame[]
  rankings           Ranking[]

  @@index([username])
  @@index([province])
}

model Character {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  icon        String
  series      String
  dlc         Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relaciones
  skins          CharacterSkin[]
  userCharacters UserCharacter[]
  registrations  Registration[]

  @@index([slug])
}

model Stage {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  image       String
  legal       Boolean  @default(true)
  starter     Boolean  @default(false)  // Starter stages (available in game 1)
  counterpick Boolean  @default(false)  // Counterpick stages (available after game 1)
  order       Int      @default(0)      // Display order
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([slug])
  @@index([legal])
}

model CharacterSkin {
  id          String   @id @default(cuid())
  characterId String
  name        String
  number      Int
  image       String
  createdAt   DateTime @default(now())

  // Relaciones
  character     Character        @relation(fields: [characterId], references: [id], onDelete: Cascade)
  userCharacters UserCharacter[]
  registrations Registration[]

  @@unique([characterId, number])
  @@index([characterId])
}

model UserCharacter {
  id         String   @id @default(cuid())
  userId     String
  characterId String
  skinId     String
  isPrimary  Boolean  @default(false)
  createdAt  DateTime @default(now())

  // Relaciones
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  character Character     @relation(fields: [characterId], references: [id], onDelete: Cascade)
  skin      CharacterSkin @relation(fields: [skinId], references: [id], onDelete: Cascade)

  @@unique([userId, characterId, skinId])
  @@index([userId])
}

model Tournament {
  id                String           @id @default(cuid())
  name              String
  description       String?
  slug              String           @unique
  banner            String?
  province          String
  isOnline          Boolean          @default(false)
  format            TournamentFormat
  status            TournamentStatus @default(DRAFT)
  maxParticipants   Int?
  currentParticipants Int           @default(0)
  
  // Prize Pool
  prizePool         String?          // "$100 PRIZE POT"
  
  // Fechas
  startDate         DateTime
  registrationStart DateTime
  registrationEnd   DateTime
  checkinStart      DateTime
  checkinEnd        DateTime
  
  // Reglas
  rules             String?
  stageList         String?
  starterStages     String[]         // IDs de starter stages (para game 1)
  counterpickStages String[]         // IDs de counterpick stages (para game 2+)
  ruleset           Json?
  
  // Streaming
  streamUrls        String[]         // Array de URLs de streams
  
  // Show/Hide options
  showProjected     Boolean          @default(true)
  
  // Metadata
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  createdById       String

  // Relaciones
  creator       User           @relation("TournamentCreator", fields: [createdById], references: [id])
  registrations Registration[]
  matches       Match[]
  rankings      Ranking[]

  @@index([slug])
  @@index([province])
  @@index([status])
  @@index([startDate])
}

model Registration {
  id             String   @id @default(cuid())
  userId         String
  tournamentId   String
  characterId    String?
  skinId         String?
  
  // Seeding
  seed           Int?     // 1-32, etc.
  seedBadge      String?  // "A1", "B2", etc.
  
  // Status in tournament
  status         String   @default("ACTIVE") // "ACTIVE", "ELIMINATED", "DQ"
  currentBracket String   @default("WINNERS") // "WINNERS", "LOSERS", "OUT"
  finalPlacement Int?     // 1st, 2nd, 3rd, Top 8, etc.
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relaciones
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  character  Character? @relation(fields: [characterId], references: [id])
  skin       CharacterSkin? @relation(fields: [skinId], references: [id])

  @@unique([userId, tournamentId])
  @@index([tournamentId])
  @@index([userId])
  @@index([seed])
  @@index([status])
}

model Match {
  id               String      @id @default(cuid())
  tournamentId     String
  
  // Bracket structure (Double Elimination)
  bracketType      String      // "WINNERS", "LOSERS", "GRANDS"
  roundName        String      // "Winners Round 1", "Losers Quarter-Final", etc.
  roundNumber      Int         // 1, 2, 3...
  position         Int         // Position within the round
  
  // Legacy fields (deprecated - kept for backward compatibility)
  round            Int         // DEPRECATED: Use roundNumber
  matchNumber      Int         // DEPRECATED: Use position
  
  // Players
  player1Id        String?
  player1Source    String?     // "Winner of Match #5" or "Loser of Match #3"
  player2Id        String?
  player2Source    String?
  
  // Results
  player1Score     Int         @default(0)
  player2Score     Int         @default(0)
  winnerId         String?
  loserId          String?
  
  // State
  status           String      @default("PENDING") // "PENDING", "ONGOING", "COMPLETED", "DQ"
  scheduledTime    DateTime?
  completedAt      DateTime?
  
  // Check-in
  player1CheckIn   Boolean     @default(false)
  player2CheckIn   Boolean     @default(false)
  checkInDeadline  DateTime?
  
  // Current game state
  currentGame      Int         @default(1)
  bestOf           Int         @default(3)
  
  // DSR (Dave's Stupid Rule) tracking
  player1WonStages String[]    // Array de IDs de stages donde player1 ganó
  player2WonStages String[]    // Array de IDs de stages donde player2 ganó
  
  // Match data (stores ban/pick history)
  matchData        Json?       // { games: [{ bans: [], stage: "", characters: {}, winner: "" }] }
  
  // Relationships in bracket
  nextMatchId      String?     // Where winner goes
  nextLoserMatchId String?     // Where loser goes (only for Winners bracket)
  previousMatch1Id String?     // Source match 1
  previousMatch2Id String?     // Source match 2
  
  // Additional metadata
  streamUrl        String?     // Twitch/YouTube stream URL
  isLive           Boolean     @default(false)
  notes            String?
  
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  // Relaciones
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  player1    User?      @relation("Player1", fields: [player1Id], references: [id])
  player2    User?      @relation("Player2", fields: [player2Id], references: [id])
  winner     User?      @relation("MatchWinner", fields: [winnerId], references: [id])
  games      MatchGame[]

  @@index([tournamentId])
  @@index([bracketType])
  @@index([roundNumber])
  @@index([player1Id])
  @@index([player2Id])
  @@index([winnerId])
  @@index([status])
  @@index([isLive])
}

model MatchGame {
  id            String   @id @default(cuid())
  matchId       String
  gameNumber    Int      // 1, 2, or 3 for BO3
  
  // Phase tracking
  phase         String   @default("LOBBY") // "LOBBY", "CHARACTER_SELECT", "STAGE_BAN", "STAGE_SELECT", "PLAYING", "REPORTING", "COMPLETED"
  currentTurn   String?  // "PLAYER1" or "PLAYER2" - who needs to act
  
  // Previous game result (for games 2-3)
  previousWinnerId String? // ID del ganador del juego anterior
  
  // Stage banning/selection
  bannedStages    String[] // Array de IDs de stages baneados
  bannedByPlayer1 String[] // Stages banned by player 1
  bannedByPlayer2 String[] // Stages banned by player 2
  selectedStage   String?  // ID del stage seleccionado
  
  // Character selection
  player1Character String?
  player2Character String?
  
  // Turn tracking for banning (Game 1: 1-2-1 pattern)
  banTurnCount     Int      @default(0) // Tracks how many bans have been made
  
  // Lobby status
  player1JoinedLobby Boolean @default(false)
  player2JoinedLobby Boolean @default(false)
  
  // Result
  winnerId      String?
  reportedBy    String?  // User ID who reported
  confirmedBy   String?  // User ID who confirmed
  
  status        String   @default("PENDING") // "PENDING", "IN_PROGRESS", "COMPLETED"
  completedAt   DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relaciones
  match   Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  winner  User? @relation(fields: [winnerId], references: [id])

  @@unique([matchId, gameNumber])
  @@index([matchId])
  @@index([winnerId])
  @@index([phase])
}

model Ranking {
  id           String   @id @default(cuid())
  userId       String
  tournamentId String
  placement    Int
  points       Int      @default(0)
  createdAt    DateTime @default(now())

  // Relaciones
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@unique([userId, tournamentId])
  @@index([userId])
  @@index([tournamentId])
  @@index([points])
}
